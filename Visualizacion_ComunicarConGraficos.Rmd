---
title: "Visualizacion - Comunicar con Graficos"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r setup, include= FALSE}

library(tidyverse)
library(datos)
library(ggrepel)
library(viridis)
```

para más información https://ggplot2.tidyverse.org/reference/  

## Etiquetas 

labs() es una de las funciones que podemos utilizar para agregar etiquetas
```{r labs_titulo_subtitulo_caption}
ggplot(millas, aes(cilindrada, autopista)) +
  geom_point(aes(color = clase)) +
  geom_smooth(se = FALSE) +
  labs(
    title = "La eficiencia del combustible generalmente disminuye con el tamaño del motor",
    subtitle = "Los automóviles deportivos de dos asientos son la excepción debido a su peso liviano",
    caption = "Datos de fueleconomy.gov"
  )
```
También se puede usar labs() para cambiar nombre de ejes, y de los cuadros por ejemplo de color.

```{r labs_ejes_cuadros}
ggplot(millas, aes(cilindrada, autopista)) +
  geom_point(aes(colour = clase)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Tamaño del motor (litros)",
    y = "Economía de combustible de carretera (millas)",
    colour = "Tipo de automóvil"
  )
```
En los ejes también se pueden escribir fórmulas con quote(): Más acerca de opciones disponibles en  ?plotmath
```{r quote}
df <- tibble(
  x = runif(10),
  y = runif(10)
)

ggplot(df, aes(x, y)) +
  geom_point() +
  labs(
    x = quote(sum(x[i]^2, i == 1, n)),
    y = quote(alpha + beta + frac(delta, theta))
  )
```

## Anotaciones
Para etiquetar partes principales del gráfico, grupos de observaciones u observaciones individuales. * geom_text(): es similar a geom_point() pero agrega label. Ojo que se pueden superponer...
* geom_label(): arma un recuadro alrededor del texto. También se puede superponer (con opción nudge_y se mueve el label un poco por encima)
* paquete ggrepel: ajusta automáticamente las etiquetas para que no se superpongan.

```{r geom_text geom_label geom_label_repel}
mejor_de_su_clase <- millas %>%   
  group_by(clase) %>%
  filter(row_number(desc(autopista)) == 1)

ggplot(millas, aes(cilindrada, autopista)) +    #geom_text   
  geom_point(aes(colour = clase)) +
  geom_text(aes(label = modelo), data = mejor_de_su_clase)

ggplot(millas, aes(cilindrada, autopista)) +    #geom_label
  geom_point(aes(colour = clase)) +
  geom_label(aes(label = modelo), data = mejor_de_su_clase, nudge_y = 2, alpha = 0.5)

ggplot(millas, aes(cilindrada, autopista)) +    #ggrepel::geom_label_repel
  geom_point(aes(colour = clase)) +
  geom_point(size = 3, shape = 1, data = mejor_de_su_clase) +
  ggrepel::geom_label_repel(aes(label = modelo), data = mejor_de_su_clase)

# técnica muy práctica utilizada aquí: agregar  segunda capa de puntos grandes y huecos para resaltar los puntos etiquetados.
```
También se puede utilizar esta técnica para eliminar la leyenda del cuadro, y que los textos esten en el mismo gráfico. 

```{r geom_label_repel y legend.position none}
clase_promedio <- millas %>%
  group_by(clase) %>%
  summarise(
    cilindrada = median(cilindrada),
    autopista = median(autopista)
  )

ggplot(millas, aes(cilindrada, autopista, colour = clase)) +
  ggrepel::geom_label_repel(aes(label = clase),
    data = clase_promedio,
    size = 6,
    label.size = 0,
    segment.color = NA
  ) +
  geom_point() +
  theme(legend.position = "none")
```
También se puede querer agregar una única leyenda al gráfico. pero igualmente hay que generar un set de datos.  
**Notar el /n en el texto para que se imprima en 2 lineas**  
**Otra posibilidad es usar  stringr::str_wrap() para agregar saltos de línea automáticamente, dado el número de caracteres que se desea por línea.**

```{r str_wrap}
"El aumento del tamaño del motor está relacionado con la disminución en el gasto de combustible." %>%
  stringr::str_wrap(width = 40) %>%
  writeLines()
#> El aumento del tamaño del motor está
#> relacionado con la disminución en el
#> gasto de combustible.
```

```{r unico_texto_vjust_hjust}
etiqueta <- millas %>%       # derecha arriba según datos máximos
  summarise(
    cilindrada = max(cilindrada),
    autopista = max(autopista),
    etiqueta = "El aumento del tamaño del motor está \nrelacionado con la disminución en el gasto de combustible."
  )

ggplot(millas, aes(cilindrada, autopista)) +
  geom_point() +
  geom_text(aes(label = etiqueta), data = etiqueta, vjust = "top", hjust = "right")



```
Si deseas colocar el texto exactamente en los bordes del gráfico puedes usar +Inf y -Inf. Como ya no estamos calculando las posiciones de millas, podemos usar tibble() para crear el conjunto de datos:
```{r geom_text Inf -Inf }
# etiqueta <- millas %>%
#   summarise(
#     cilindrada = Inf,
#     autopista = Inf,
#     etiqueta = "El aumento del tamaño del motor está \nrelacionado con la disminución en el gasto de combustible."
#  ) 
etiqueta <- tribble(
  ~cilindrada, ~ autopista, ~ etiqueta,
    Inf, Inf, "El aumento del tamaño del motor está \nrelacionado con la disminución en el gasto de combustible."
)

ggplot(millas, aes(cilindrada, autopista)) +
  geom_point() +
  geom_text(aes(label = etiqueta), data = etiqueta, vjust = "top", hjust = "right")
```

## Posiciones vjust_hjust para agregar etiquetas
 ![](vjust_hjust.JPG)


## Para recordar.. otros geoms para ayudar y agregar texto:

* geom_hline y geom_vline para agregar lineas de referencia.  A menudo las hago gruesas (size = 2) y blancas (color = white), y las dibujo debajo de la primera capa de datos. Eso las hace fáciles de ver, sin distraer la atención de los datos.  
*  geom_rect() para dibujar un rectángulo alrededor de los puntos de interés. Los límites del rectángulo están definidos por las estéticas xmin,xmax, ymin,ymax  
*  geom_segment() con el argumento arrow para destacar un punto en particular con una flecha. Usa la estética x e y para definir la ubicación inicial, y xend y yend para definir la ubicación final.


```{r geom_hlilne geom_vline geom_abline}
p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
p + geom_vline(xintercept = 5, size = 2, color = "white") # muestra la linea en blanco y con grosor
p + geom_vline(xintercept = 1:5)
p + geom_hline(yintercept = 20)
p + geom_abline() # Can't see it - outside the range of the data
p + geom_abline(intercept = 20)
# Calculate slope and intercept of line of best fit
coef(lm(mpg ~ wt, data = mtcars))
p + geom_abline(intercept = 37, slope = -5)
# But this is easier to do with geom_smooth:
p + geom_smooth(method = "lm", se = FALSE)
#different lines in different facets
p <- ggplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  facet_wrap(~ cyl)
mean_wt <- data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
p + geom_hline(aes(yintercept = wt), mean_wt)
```

```{r geom_rect}
p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
p + geom_rect(xmin = 1.5, xmax = 2.5, ymin = 32, ymax = 35, color = "grey", alpha = 0.01)
#colors() para ver el nombre de los 657 colores
```
```{r geom_segment}
b <- ggplot(mtcars, aes(wt, mpg)) +
  geom_point()
df <- data.frame(x1 = 2.62, x2 = 3.57, y1 = 21.0, y2 = 15.0)
b +
  geom_curve(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "curve"), 
             arrow = arrow(length = unit(0.3,"cm")), data = df) +
 geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2, colour = "segment"), 
              arrow = arrow(length = unit(0.3,"cm")) , data = df)
#x e y para definir la ubicación inicial, y xend y yend para definir la ubicación final
```


## otros geoms_utiles para incluir texto

```{r annotate}
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate("text", x = 4, y = 25, label = "Some text")
p + annotate("text", x = 2:5, y = 25, label = "Some text")
p + annotate("rect", xmin = 3, xmax = 4.2, ymin = 12, ymax = 21,
  alpha = .2)
p + annotate("segment", x = 2.5, xend = 4, y = 15, yend = 25,
  colour = "blue")
p + annotate("pointrange", x = 3.5, y = 20, ymin = 12, ymax = 28,
  colour = "red", size = 1.5)

p + annotate("text", x = 2:3, y = 20:21, label = c("my label", "label 2"))
p + annotate("text", x = 4, y = 25, label = "italic(R) ^ 2 == 0.75",
  parse = TRUE)
p + annotate("text", x = 4, y = 25,
  label = "paste(italic(R) ^ 2, \" = .75\")", parse = TRUE)

```

